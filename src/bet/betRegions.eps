import bet.betRule;

import utils.rect;
import utils.loc;
import utils.utils;

object BetRegion {
    var pos: rect.Rect;
    var betHereUnitEPD;
    var betHandler: EUDFuncPtr(1, 1);
};

const betLocations = EUDArray(400);
var betLocationCount = 0;

function registerBetRegion(x, y, w, h, handler: EUDFuncPtr(1, 1)) {
    const obj = BetRegion.alloc();
    const pos = rect.Rect.alloc();
    pos.x = x;
    pos.y = y;
    pos.w = w;
    pos.h = h;
    obj.pos = pos;
    obj.betHandler = handler;
    betLocations[betLocationCount] = obj;
    betLocationCount++;
}

function registerBetLocation(locId, handler: EUDFuncPtr(1, 1)) {
    const x, y, w, h = loc.getLocationPos(locId);
    registerBetRegion(x, y, w, h, handler);
}

function initBetRegions() {
    registerBetLocation($L("bet-1-12"), betRule.bet_btw(1, 12));
    registerBetLocation($L("bet-13-24"), betRule.bet_btw(13, 24));
    registerBetLocation($L("bet-25-36"), betRule.bet_btw(25, 36));
    registerBetLocation($L("bet-1-18"), betRule.bet_btw(1, 18));
    registerBetLocation($L("bet-19-36"), betRule.bet_btw(19, 36));
    registerBetLocation($L("bet-even"), betRule.bet_multiple(2, 0));
    registerBetLocation($L("bet-odd"), betRule.bet_multiple(2, 1));
    registerBetLocation($L("bet-dark"), betRule.bet_dark());
    registerBetLocation($L("bet-light"), betRule.bet_light());
    registerBetLocation($L("bet-3n+0"), betRule.bet_multiple(3, 0));
    registerBetLocation($L("bet-3n+2"), betRule.bet_multiple(3, 2));
    registerBetLocation($L("bet-3n+1"), betRule.bet_multiple(3, 1));
    registerBetLocation($L("bet-0"), betRule.bet_exact(0));

    // 숫자에 베팅
    const x0, y0 = loc.getLocationPos($L('bet-1'))[[0, 1]];
    for(var y = 0 ; y < 3 ; y++) {
        for(var x = 0 ; x < 12 ; x++) {
            const px0 = x0 + x * (8 * 32) + 2 * 32;
            const py0 = y0 - y * (8 * 32) + 2 * 32;
            const pw, ph = 3 * 32, 3 * 32;
            const num = x * 3 + y + 1;
            registerBetRegion(px0, py0, pw, ph, betRule.bet_exact[num]);
        }
    }

    var cornerBetStart = betLocationCount;

    // 코너에 베팅
    for(var y = 0 ; y < 2 ; y++) {
        for(var x = 0 ; x < 11 ; x++) {
            const px0 = x0 + x * (8 * 32) + 6 * 32;
            const py0 = y0 - y * (8 * 32) - 2 * 32;
            const pw, ph = 3 * 32, 2 * 32;
            const num = x * 3 + y + 1;
            registerBetRegion(px0, py0, pw, ph, betRule.bet_corner[num]);
        }
    }

    for(var i = 0 ; i < betLocationCount ; i++) {
        const obj = BetRegion.cast(betLocations[i]);
        const pos = obj.pos;
        const x, y, w, h = pos.x, pos.y, pos.w, pos.h;
        loc.pxMoveTo(x + w / 2, y + h / 2);

        const uptr, uepd = utils.getNextGeneratedUnit();

        if(i >= cornerBetStart) {
            CreateUnit(1, "코너에 베팅합니다", "pxMove", P8);
        }
        else {
            CreateUnit(1, "칸에 베팅합니다", "pxMove", P7);
        }
        obj.betHereUnitEPD = uepd;
        utils.setUnitPassable(uepd);
    }
}

function forBetRegion(ballNum, callback: EUDFuncPtr(1, 0)) {
    for(var i = 0 ; i < betLocationCount ; i++) {
        const obj = BetRegion.cast(betLocations[i]);
        const multiplier = obj.betHandler(ballNum);
        if(multiplier) {
            (callback)(obj);
        }
    }
}
