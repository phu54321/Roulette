import loc;
import utils;
import betRule;
import rect;

object BetLoc {
    var pos: rect.Rect;
    var betHereUnitEPD;
    var betHandler: EUDFuncPtr(1, 1);
};

const betLocations = EUDArray(4 * 4000);
var betLocationCount = 0;

function registerBetLocation(x, y, w, h, handler: EUDFuncPtr(1, 1)) {
    const obj = BetLoc.alloc();
    const pos = rect.Rect.alloc();
    pos.x = x;
    pos.y = y;
    pos.w = w;
    pos.h = h;
    obj.pos = pos;
    obj.betHandler = handler;
    betLocations[betLocationCount] = obj;
    betLocationCount++;
}

function registerBetLocationByID(locId, handler: EUDFuncPtr(1, 1)) {
    const x, y, w, h = loc.getLocationPos(locId);
    registerBetLocation(x, y, w, h, handler);
}

function initBetLocations() {
    registerBetLocationByID($L("bet-1-12"), betRule.bet_btw(1, 12));
    registerBetLocationByID($L("bet-13-24"), betRule.bet_btw(13, 24));
    registerBetLocationByID($L("bet-25-36"), betRule.bet_btw(25, 36));
    registerBetLocationByID($L("bet-1-18"), betRule.bet_btw(1, 18));
    registerBetLocationByID($L("bet-19-36"), betRule.bet_btw(19, 36));
    registerBetLocationByID($L("bet-even"), betRule.bet_multiple(2, 0));
    registerBetLocationByID($L("bet-odd"), betRule.bet_multiple(2, 1));
    registerBetLocationByID($L("bet-dark"), betRule.bet_dark());
    registerBetLocationByID($L("bet-light"), betRule.bet_light());
    registerBetLocationByID($L("bet-3n+0"), betRule.bet_multiple(3, 0));
    registerBetLocationByID($L("bet-3n+2"), betRule.bet_multiple(3, 2));
    registerBetLocationByID($L("bet-3n+1"), betRule.bet_multiple(3, 1));
    registerBetLocationByID($L("bet-0"), betRule.bet_exact(0));

    // 숫자에 베팅
    const x0, y0 = loc.getLocationPos($L('bet-1'))[[0, 1]];
    for(var y = 0 ; y < 3 ; y++) {
        for(var x = 0 ; x < 12 ; x++) {
            const px0 = x0 + x * (8 * 32) + 2 * 32;
            const py0 = y0 - y * (8 * 32) + 2 * 32;
            const pw, ph = 3 * 32, 3 * 32;
            const num = x * 3 + y + 1;
            registerBetLocation(px0, py0, pw, ph, betRule.bet_exact[num]);
        }
    }

    var nzBetLocationCount = betLocationCount;

    // 코너에 베팅
    for(var y = 0 ; y < 2 ; y++) {
        for(var x = 0 ; x < 11 ; x++) {
            const px0 = x0 + x * (8 * 32) + 6 * 32;
            const py0 = y0 - y * (8 * 32) - 2 * 32;
            const pw, ph = 3 * 32, 3 * 32;
            const num = x * 3 + y + 1;
            registerBetLocation(px0, py0, pw, ph, betRule.bet_corner[num]);
        }
    }

    SetResources(AllPlayers, SetTo, betLocationCount, 0);
    for(var i = 0 ; i < betLocationCount ; i++) {
        const obj = BetLoc.cast(betLocations[i]);
        const pos = obj.pos;
        const x, y, w, h = pos.x, pos.y, pos.w, pos.h;
        loc.pxMoveTo(x + w / 2, y + h / 2);

        const uptr, uepd = utils.getNextGeneratedUnit();

        if(i < nzBetLocationCount) {
            CreateUnit(1, "칸에 베팅합니다", "pxMove", P7);
        }
        else {
            CreateUnit(1, "코너에 베팅합니다", "pxMove", P8);

        }
        obj.betHereUnitEPD = uepd;
    }
}

function applyBet(num) {
    for(var i = 0 ; i < betLocationCount ; i++) {
        const obj = BetLoc.cast(betLocations[i]);
        const multiplier = obj.betHandler(num);
        if(multiplier) {
            const pos = obj.pos;
            const x, y, w, h = pos.x, pos.y, pos.w, pos.h;
            loc.pxMoveTo(x + w / 2, y + h / 2);
            CreateUnit(1, "Terran Wraith", "pxMove", P7);
        }
    }

}